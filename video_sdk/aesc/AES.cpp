/*
程序采用字节流的形式进行加解密，将输入的密钥，明文或者密文都看作是流的形式进行操作
*/
extern "C" {
#include <stdio.h>
#include <time.h>     
#include <fstream>  
#define Num_OF_AES_Round 14          //定义256比特对应轮数
#define Size_OF_AES_Block 16        //定义分块字节数
using namespace std;

/*定义S盒,操作方式：只读*/
const unsigned char Sbox[256] = {
	0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};

/*定义逆S盒,操作方式：只读*/
const unsigned char InvSbox[256] = {
	0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,    
	0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};

/*有限域上乘2预计算表格，操作方式：只读*/
const unsigned char Multable_2[256] = {
	0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e,	0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e,
	0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e,	0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e,
	0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e,	0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e,
	0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e,	0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e,
	0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e,	0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e,
	0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae,	0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe,
	0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce,	0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde,
	0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee,	0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe,
	0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15,	0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05,
	0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35,	0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25,
	0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55,	0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45,
	0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75,	0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65,
	0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95,	0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85,
	0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5,	0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5,
	0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5,	0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5,
	0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5,	0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5,
};

/*有限域上乘3预计算表格，操作方式：只读*/
const unsigned char Multable_3[256] = {
	0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09,	0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11,
	0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39,	0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21,
	0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69,	0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71,
	0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59,	0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41,
	0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9,	0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1,
	0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9,	0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1,
	0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9,	0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1,
	0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99,	0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81,
	0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92,	0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a,
	0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2,	0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba,
	0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2,	0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea,
	0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2,	0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda,
	0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52,	0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a,
	0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62,	0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a,
	0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32,	0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a,
	0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02,	0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a,
};

/*有限域上乘9预计算表格，操作方式：只读*/
const unsigned char Multable_9[256] = {
	0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f,	0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77,
	0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf,	0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7,
	0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04,	0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c,
	0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94,	0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc,
	0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49,	0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01,
	0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9,	0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91,
	0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72,	0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a,
	0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2,	0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa,
	0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3,	0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b,
	0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43,	0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b,
	0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8,	0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0,
	0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78,	0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30,
	0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5,	0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed,
	0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35,	0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d,
	0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e,	0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6,
	0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e,	0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46,
};

/*有限域上乘b预计算表格，操作方式：只读*/
const unsigned char Multable_b[256] = {
	0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31,	0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69,
	0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81,	0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9,
	0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a,	0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12,
	0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa,	0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2,
	0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7,	0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f,
	0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77,	0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f,
	0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc,	0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4,
	0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c,	0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54,
	0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6,	0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e,
	0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76,	0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e,
	0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd,	0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5,
	0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d,	0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55,
	0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30,	0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68,
	0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80,	0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8,
	0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b,	0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13,
	0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb,	0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3,
};

/*有限域上乘d预计算表格，操作方式：只读*/
const unsigned char Multable_d[256] = {
	0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23,	0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b,
	0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3,	0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b,
	0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98,	0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0,
	0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48,	0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20,
	0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e,	0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26,
	0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e,	0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6,
	0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5,	0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d,
	0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25,	0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d,
	0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9,	0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91,
	0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29,	0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41,
	0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42,	0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a,
	0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92,	0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa,
	0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94,	0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc,
	0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44,	0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c,
	0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f,	0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47,
	0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff,	0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97,
};

/*有限域上乘e预计算表格，操作方式：只读*/
const unsigned char Multable_e[256] = {
	0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a,	0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a,
	0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca,	0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba,
	0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1,	0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81,
	0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11,	0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61,
	0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87,	0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7,
	0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67,	0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17,
	0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c,	0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c,
	0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc,	0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc,
	0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b,	0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b,
	0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b,	0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb,
	0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0,	0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0,
	0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50,	0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20,
	0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6,	0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6,
	0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26,	0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56,
	0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d,	0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d,
	0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd,	0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d,
};

/*定义轮常数，操作方式：只读*/
const unsigned char AES_Round_Constant[30] = {
	0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
	0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
	0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5
};

/*定义初始向量，操作方式：只读*/
const unsigned char initvec[16] = {
	0x39, 0xef, 0x8b, 0xc9, 0xdb, 0x5f, 0xea, 0xb7, 0xa6, 0x68, 0x19, 0x21, 0xaf, 0xb1, 0x3d, 0x17,
};

void SubBytes(unsigned char *state, const unsigned char box[256]);                                         /*字节代换函数原型*/
void ShiftRows(unsigned char *state);                                                                      /*行移位函数原型*/
void InvShiftRows(unsigned char *state);                                                                   /*逆行移位函数原型*/
void AddRoundKey(unsigned char *state, unsigned char *RndKey, int round);                                  /*轮密钥加函数原型*/
void MixColumn(unsigned char *state);                                                                      /*列混淆函数原型*/
void InvMixColumn(unsigned char *state);                                                                   /*逆向列混淆函数原型*/
void KeyExpansion(unsigned char *key, unsigned char *RndKey);                                              /*密钥扩展函数原型*/
void Encrypt(unsigned char *datain, unsigned char *RndKey, unsigned char *dataout);                        /*加密函数原型*/
void Decrypt(unsigned char *datain, unsigned char *RndKey, unsigned char *dataout);                        /*解密函数原型*/
int AESCBCEnc(unsigned char *datain, unsigned long int length, unsigned char *key, unsigned char *dataout);/*CBC加密函数原型*/
int AESCBCDec(unsigned char *datain, unsigned long int length, unsigned char *key, unsigned char *dataout);/*CBC加密函数原型*/
int SelfCheck();    


/********************************************************************/
/*                        字节代换函数实现                          */
/*
输入：state指向待处理字符串;box数组指明是加密还是解密
输出：字节代换后的state数组
主要思想:根据所给表格实行查表运算
*/
/*                        字节代换函数实现                          */
/********************************************************************/
void SubBytes(unsigned char *state, const unsigned char box[256])
{
	int cnt;
	for(cnt = 0; cnt < Size_OF_AES_Block; cnt++)
		state[cnt] = box[state[cnt]];
}


/********************************************************************/
/*                        行移位函数实现                            */
/*
输入输出：state数组
*/
/*                        行移位函数实现                            */
/********************************************************************/
void ShiftRows(unsigned char *state)
{
	unsigned char temp;   

	//第二行:(1,5,9,13)->(5,9,13,1)
	temp = state[1];
	state[1] = state[5];
	state[5] = state[9];
	state[9] = state[13];
	state[13] = temp;

	//第三行:(2,6,10,14)->(10,14,2,6)
	temp = state[2];
	state[2] = state[10];
	state[10] = temp;
	temp = state[6];
	state[6] = state[14];
	state[14] = temp;
	
	//第四行:(3,7,11,15)->(7,11,15,3)
	temp = state[3];
	state[3] = state[15];
	state[15] = state[11];
	state[11] = state[7];
	state[7] = temp;
}


/********************************************************************/
/*                    逆向行移位函数实现                            */
/*
输入输出：state数组
*/
/*                    逆向行移位函数实现                            */
/********************************************************************/
void InvShiftRows(unsigned char *state)
{
	unsigned char temp;   
	
	//第二行:(1,5,9,13)->(5,9,13,1)
	temp = state[13];
	state[13] = state[9];
	state[9] = state[5];
	state[5] = state[1];
	state[1] = temp;

	//第三行:(2,6,10,14)->(10,14,2,6)
	temp = state[2];
	state[2] = state[10];
	state[10] = temp;
	temp = state[6];
	state[6] = state[14];
	state[14] = temp;
		
	//第四行:(3,7,11,15)->(15,3,7,11)
	temp = state[7];
	state[7] = state[11];
	state[11] = state[15];
	state[15] = state[3];
	state[3] = temp;
}


/********************************************************************/
/*                    轮密钥加函数实现                              */
/*
输入：state指向待处理字符串;RndKey指向轮密钥串,round表示当前的轮数
输出：state字节数组
*/
/*                    轮密钥加函数实现                              */
/********************************************************************/
void AddRoundKey(unsigned char *state, unsigned char *RndKey, int round)
{
	int cnt;

	for(cnt = 0; cnt < Size_OF_AES_Block; cnt++)
		state[cnt] = state[cnt] ^ RndKey[(round << 4) + cnt];
}


/********************************************************************/
/*                            列混淆函数实现                        */
/*
输入输出：数组state
*/
/*                            列混淆函数实现                        */
/********************************************************************/
void MixColumn(unsigned char *state)
{
	int cnt, cur;
	unsigned char result[16] = {0x00};              //保存中间结果，完成一列的计算后回送至state中
	int temp1, temp2, temp3;

		for(cnt = 0; cnt < Size_OF_AES_Block; cnt = cnt + 4)
		{			
			temp1 = cnt + 1;
			temp2 = cnt + 2;
			temp3 = cnt + 3;

			result[cnt]   = Multable_2[state[cnt]] ^ Multable_3[state[temp1]] ^ state[temp2] ^ state[temp3];
			result[temp1] = state[cnt] ^ Multable_2[state[temp1]] ^ Multable_3[state[temp2]] ^ state[temp3];
			result[temp2] = state[cnt] ^ state[temp1] ^ Multable_2[state[temp2]] ^ Multable_3[state[temp3]];
			result[temp3] = Multable_3[state[cnt]] ^ state[temp1] ^ state[temp2] ^ Multable_2[state[temp3]];
		
			for(cur = 0; cur < 4; cur++)
				state[cnt + cur] = result[cnt + cur];         
		}
}


/********************************************************************/
/*                        逆向列混淆函数实现                        */
/*
输入输出：数组state
*/
/*                        逆向列混淆函数实现                        */
/********************************************************************/
void InvMixColumn(unsigned char *state)
{
	int cnt, cur;
	unsigned char result[16] = {0x00};              //保存中间结果，完成一列的计算后回送至state中
	int temp1, temp2, temp3;
	
	for(cnt = 0; cnt < Size_OF_AES_Block; cnt = cnt + 4)
	{
		temp1 = cnt + 1;
		temp2 = cnt + 2;
		temp3 = cnt + 3;

		result[cnt]   = Multable_e[state[cnt]] ^ Multable_b[state[temp1]] ^ Multable_d[state[temp2]] ^ Multable_9[state[temp3]];
		result[temp1] = Multable_9[state[cnt]] ^ Multable_e[state[temp1]] ^ Multable_b[state[temp2]] ^ Multable_d[state[temp3]];
		result[temp2] = Multable_d[state[cnt]] ^ Multable_9[state[temp1]] ^ Multable_e[state[temp2]] ^ Multable_b[state[temp3]];
		result[temp3] = Multable_b[state[cnt]] ^ Multable_d[state[temp1]] ^ Multable_9[state[temp2]] ^ Multable_e[state[temp3]];
		
		for(cur = 0; cur < 4; cur++)
			state[cnt + cur] = result[cnt + cur];
	}
}


/********************************************************************/
/*                        密钥扩展函数实现                          */
/*
输入：32字节种子密钥数据key
输出：轮密钥数组RndKey
*/
/*                         密钥扩展函数实现                         */
/********************************************************************/
void KeyExpansion(unsigned char *key, unsigned char *RndKey)
{
	int cnt, cur;
	unsigned char temp[4], bytemp;

	for(cnt = 0; cnt < 32; cnt++)
	{
		RndKey[cnt] = key[cnt];
	}
	
	for(cnt = 32; cnt < 240; cnt = cnt + 4)
	{
		for(cur = 0; cur < 4; cur++)
			temp[cur] = RndKey[cnt + cur - 4];
		if((cnt & 0x1f) == 0)
		{
			bytemp = temp[0];                           //temp左移一字节
			for(cur = 0; cur < 4; cur++)
				temp[cur] = temp[cur + 1];
			temp[3] = bytemp;
			for(cur = 0; cur < 4; cur++)
				temp[cur] = Sbox[temp[cur]];             //字节代换
			temp[0] = temp[0] ^ AES_Round_Constant[cnt / 32];
		}

		else if((cnt & 0x1f) == 16)
			for(cur = 0; cur < 4; cur++)
				temp[cur] = Sbox[temp[cur]];

		for(cur = 0; cur < 4; cur++)
			RndKey[cnt + cur] = temp[cur] ^ RndKey[cnt + cur - 32];
			
	}
}


/********************************************************************/
/*                         AES加密函数实现                          */
/*
输入：待处理的16字节数据datain，轮密钥数组RndKey
输出：处理后的16字节数据dataout
*/
/*                         AES加密函数实现                          */
/********************************************************************/
void Encrypt(unsigned char *datain,unsigned char *RndKey, unsigned char *dataout)
{
	int cnt;

	for(cnt = 0; cnt < Size_OF_AES_Block; cnt++)
		dataout[cnt] = datain[cnt];

	AddRoundKey(dataout, RndKey, 0);
	for(cnt = 1; cnt < Num_OF_AES_Round; cnt++)
	{
		SubBytes(dataout, Sbox);
		ShiftRows(dataout);
		MixColumn(dataout);
		AddRoundKey(dataout, RndKey, cnt);
	}
	SubBytes(dataout, Sbox);
	ShiftRows(dataout);
	AddRoundKey(dataout, RndKey, Num_OF_AES_Round);
}


/********************************************************************/
/*                         AES解密函数实现                          */
/*
输入：待处理的16字节数据datain，轮密钥数组RndKey
输出：处理后的16字节数据dataout
*/
/*                         AES解密函数实现                          */
/********************************************************************/
void Decrypt(unsigned char *datain,unsigned char *RndKey, unsigned char *dataout)
{
	int cnt;

	for(cnt = 0; cnt < Size_OF_AES_Block; cnt++)
		dataout[cnt] = datain[cnt];

	AddRoundKey(dataout, RndKey, Num_OF_AES_Round);
	for(cnt = Num_OF_AES_Round - 1; cnt > 0; cnt--)
	{
		InvShiftRows(dataout);
		SubBytes(dataout, InvSbox);
		AddRoundKey(dataout, RndKey, cnt);
		InvMixColumn(dataout);
	}
	InvShiftRows(dataout);
	SubBytes(dataout, InvSbox);
	AddRoundKey(dataout, RndKey, 0);
}


/********************************************************************/
/*                         CBC加密函数实现                          */
/*
输入：待处理数据datain，待处理数据字节长度length（应为16的整数倍），32字节密钥key
输出：CBC模式加密后的数据dataout（不能与datain指向同一地址）
返回：0，加密正常；0x55555555，长度错误；0xffffffff，内存分配错误
*/
/*                         CBC加密函数实现                          */
/********************************************************************/
int AESCBCEnc(unsigned char *datain, unsigned long int length, unsigned char *key, unsigned char *dataout)
{
	unsigned long int  cnt, cur;
	unsigned char *RndKey;

	if((length == 0) || ((length & 0x0f) != 0))
		return 0x55555555;
	
	RndKey = new unsigned char [481];
	if(RndKey == NULL)
		return 0xffffffff;	

	KeyExpansion(key, RndKey);

	for(cnt = 0; cnt < Size_OF_AES_Block; cnt++)
		dataout[cnt] = datain[cnt] ^ initvec[cnt]; 

	for(cnt = 0; cnt < length; cnt = cnt + Size_OF_AES_Block)
	{
		Encrypt(dataout + cnt, RndKey, dataout + cnt);

		if(cnt < length - Size_OF_AES_Block)
		{
			for(cur = 0; cur < Size_OF_AES_Block; cur++)
				dataout[cnt + cur + Size_OF_AES_Block] = dataout[cnt + cur] ^ datain[cnt + cur + Size_OF_AES_Block];
		}
	}
	
	delete [] RndKey;

	return 0;
}


/********************************************************************/
/*                         CBC解密函数实现                          */
/*
输入：待处理数据datain，待处理数据字节长度length（应为16的整数倍），32字节密钥key
输出：CBC模式解密后的数据dataout（不能与datain指向同一地址）
返回：0，加密正常；0x55555555，长度错误；0xffffffff，内存分配错误
*/
/*                         CBC解密函数实现                          */
/********************************************************************/
int AESCBCDec(unsigned char *datain, unsigned long int length, unsigned char *key, unsigned char *dataout)
{
	unsigned long int  cnt, cur;
	unsigned char *RndKey;

	if((length == 0) || ((length & 0x0f) != 0))
		return 0x55555555;
	
	RndKey = new unsigned char [481];
	if(RndKey == NULL)
		return 0xffffffff;	

	KeyExpansion(key, RndKey);
	
	for(cnt = 0; cnt < length; cnt = cnt + Size_OF_AES_Block)
	{
		Decrypt(datain + cnt, RndKey, dataout + cnt);

		if(cnt == 0)
		{
			for(cur = 0; cur < Size_OF_AES_Block; cur++)
				dataout[cur] = dataout[cur] ^ initvec[cur];
		}
		else
		{
			for(cur = 0; cur < Size_OF_AES_Block; cur++)
			{
				dataout[cnt + cur] = datain[cnt + cur - Size_OF_AES_Block] ^ dataout[cnt + cur];
			}
		}
	}
	
	delete [] RndKey;

	return 0; 
}


/********************************************************************/
/*                        自检函数实现                              */
/*
检测加密、解密功能是否正确
注意：当初始向量值发生变化时，需调整自检密文值，否则无法通过自检
返回：0，正常；1，加密自检失败；2，解密自检失败
*/
/*                        自检函数实现                              */
/********************************************************************/
int SelfCheck()
{
	unsigned char cnt;
	unsigned char selfcheck_key[32] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	};

	unsigned char selfcheck_plain[32] = {
		0xdc, 0x95, 0xc0, 0x78, 0xa2, 0x40, 0x89, 0x89, 0xad, 0x48, 0xa2, 0x14, 0x92, 0x84, 0x20, 0x87,
		0x08, 0xc3, 0x74, 0x84, 0x8c, 0x22, 0x82, 0x33, 0xc2, 0xb3, 0x4f, 0x33, 0x2b, 0xd2, 0xe9, 0xd3,
	};
	
	unsigned char selfcheck_out[32];

	unsigned char selfcheck_cipher[32] = {
		0xe1, 0x62, 0xd0, 0x70, 0xe1, 0xe5, 0x37, 0x3c, 0xb5, 0xcb, 0x0c, 0x06, 0xb0, 0x3f, 0xdd, 0x45,
		0xeb, 0xe5, 0x78, 0xab, 0xa5, 0x74, 0xdf, 0x8e, 0x41, 0xd3, 0x2b, 0xd6, 0x7e, 0x52, 0x77, 0x11,
	};

	AESCBCEnc(selfcheck_plain, 32, selfcheck_key, selfcheck_out);
	for(cnt = 0; cnt < 32; cnt++)
	{
		if(selfcheck_out[cnt] != selfcheck_cipher[cnt])
			return 1;
	}
	
	AESCBCDec(selfcheck_cipher, 32, selfcheck_key, selfcheck_out);	
	for(cnt = 0; cnt < 32; cnt++)
	{
		if(selfcheck_out[cnt] != selfcheck_plain[cnt])
			return 2;
	}

	return 0;
}
/********************************************************************/
	/*                 读文件，填充位数，加密，写入文件                 */
	/*
	输入：视频文件的本地路径path，秘钥key
	输出：输出路径path
	返回：0，输出文件；1，读文件错误；2，写文件错误
	*/
	/*                         用CBC加密函数实现                          */
	/********************************************************************/
	int EN_FILE_BY_PATH(char* path, unsigned char* key, char* outpath)
	{
		ifstream ifile(path, ios::binary | ios::in | ios::_Nocreate);
		if (!ifile)
		{
			return 1;
		}
		ifile.seekg(0, ios::end);
		unsigned long int sizeofopen = ifile.tellg();//读取文件的位数
		ifile.seekg(0, ios::beg);
		unsigned char * p = new unsigned char[sizeofopen+16];
		for (int i = 0; i < sizeofopen; i++)
		{
			ifile.read((char*)&p[i], sizeof(unsigned char));
		}
		ifile.close();
		unsigned long int bytes = 16 - sizeofopen % 16;
		for (int i = sizeofopen; i < sizeofopen + bytes - 1; i++)
		{
			p[i] = 0x00;
		}
		p[sizeofopen + bytes - 1] = bytes;
		unsigned long int sizeofbytes = sizeofopen + bytes;
		unsigned char * np = new unsigned char[sizeofbytes +16];
		int isCBC = AESCBCEnc(p, sizeofbytes, key, np);
		ofstream ofile(outpath, ios::binary | ios::out);
		if (!ofile)
		{
			delete p;
			delete np;
			return 2;
		}
		for (int i = 0; i < sizeofbytes; i++)
		{
			ofile.write((char*)&np[i], sizeof(unsigned char));
		}
		
		ofile.close();
		delete p;
		delete np;
		return 0;
		
		
	}

	/********************************************************************/
	/*                 读文件，解密，反填充，写入文件                 */
	/*
	输入：加密的本地路径path，秘钥key
	输出：输出路径path
	返回：0，输出文件；1，读文件错误；2，写文件错误
	*/
	/*                         用CBC解密函数实现                          */
	/********************************************************************/

	int DE_FILE_BY_PATH(char* path, unsigned char* key, char* outpath)
	{
		ifstream ifile(path, ios::binary | ios::in | ios::_Nocreate);
		if (!ifile)
		{
			return 1;
		}
		ifile.seekg(0, ios::end);
		unsigned long int sizeofopen = ifile.tellg();//读取文件的位数
		ifile.seekg(0, ios::beg);//返回开头
		unsigned char * p = new unsigned char[sizeofopen];
		for (int i = 0; i < sizeofopen; i++)
		{
			ifile.read((char*)&p[i], sizeof(unsigned char));
		}
		ifile.close();
		unsigned char * np = new unsigned char[sizeofopen];
		int isCBC = AESCBCDec(p, sizeofopen, key, np);//np存储解密数据
		int fillcount = np[sizeofopen - 1];
		int sizeofwrite = sizeofopen - fillcount; //写文件的大小
		ofstream ofile(outpath, ios::binary | ios::out);
		if (!ofile)
		{
			delete p;
			delete np;
			return 2;
		}
		for (int i = 0; i < sizeofwrite; i++)
		{
			ofile.write((char*)&np[i], sizeof(unsigned char));
		}
		ofile.close();
		delete p;
		delete np;
		return 0;
	}


/********************************************************************/
/*                       测试用函数                                 */
// int main()
// {
// 	int cnt, flag;

// 	unsigned char key[32] = {
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
// 	};

// 	unsigned char test_plain[32] = {
// 		0xdc, 0x95, 0xc0, 0x78, 0xa2, 0x40, 0x89, 0x89, 0xad, 0x48, 0xa2, 0x14, 0x92, 0x84, 0x20, 0x87,
// 		0x08, 0xc3, 0x74, 0x84, 0x8c, 0x22, 0x82, 0x33, 0xc2, 0xb3, 0x4f, 0x33, 0x2b, 0xd2, 0xe9, 0xd3,
// 	};

// 	unsigned char test_out[32];

// 	unsigned char test_cipher[32] = {
// 		0x08, 0xc3, 0x74, 0x84, 0x8c, 0x22, 0x82, 0x33, 0xc2, 0xb3, 0x4f, 0x33, 0x2b, 0xd2, 0xe9, 0xd3,
// 		0xdc, 0x95, 0xc0, 0x78, 0xa2, 0x40, 0x89, 0x89, 0xad, 0x48, 0xa2, 0x14, 0x92, 0x84, 0x20, 0x87,
// 	};

// 	clock_t start, finish;	
// 	double duration;	
// 	unsigned char *test_speed = new unsigned char [16 * 1024 * 1024];	
// 	unsigned char *test_speed_out = new unsigned char [16 * 1024 * 1024];

// 	for(cnt = 0; cnt < 16 * 1024 * 1024; cnt++)
// 		test_speed[cnt] = 0x00;

// 	cnt = SelfCheck();
// 	if(cnt == 0)
// 		printf("自检成功！\n");
// 	else
// 		printf("自检失败！\n");

// 	printf("速率测试！加密16MB数据所需时间：\n");
// 	start = clock();
// 	AESCBCEnc(test_speed, 16 * 1024 * 1024, key, test_speed_out);	
// 	finish = clock();
// 	duration = (double)(finish - start) / CLOCKS_PER_SEC;
// 	printf( "%f seconds\n", duration ); 

// 	printf("\n速率测试最后32字节密文：\n");
// 	for(cnt = 16 * 1024 *1024 -32; cnt < 16 * 1024 * 1024; cnt++)
// 	{
// 		printf("0x%02x, ", test_speed_out[cnt]);
// 		if((cnt & 0x07) == 0x07)
// 			printf("\n");
// 	}
// 	printf("\n");

	
// 	printf("速率测试！解密16MB数据所需时间：\n");
// 	start = clock();
// 	AESCBCDec(test_speed_out, 16 * 1024 * 1024, key, test_speed);	
// 	finish = clock();
// 	duration = (double)(finish - start) / CLOCKS_PER_SEC;
// 	printf( "%f seconds\n", duration ); 

// 	printf("\n速率测试最后32字节明文：\n");
// 	for(cnt = 16 * 1024 *1024 -32; cnt < 16 * 1024 * 1024; cnt++)
// 	{
// 		printf("0x%02x, ", test_speed[cnt]);
// 		if((cnt & 0x07) == 0x07)
// 			printf("\n");
// 	}
// 	printf("\n");

// 	delete [] test_speed;	
// 	delete [] test_speed_out;
	
// 	printf("\n加解密测试数据打印：\n");
// 	printf("\n原始明文：\n");
// 	for(cnt = 0; cnt < 32; cnt++)
// 	{
// 		printf("0x%02x, ", test_plain[cnt]);
// 		if((cnt & 0x07) == 0x07)
// 			printf("\n");
// 	}
// 	printf("\n");
 

// 	flag = AESCBCEnc(test_plain, 32, key, test_cipher);	
// 	if(flag == 0x55555555)
// 	{
// 		printf("处理数据长度错误！\n");
// 		return flag;
// 	}
// 	else if(flag == 0xffffffff)
// 	{
// 		printf("地址分配错误：\n");
// 		return flag;
// 	}


	
// 	printf("加密生成密文：\n");
// 	for(cnt = 0; cnt < 32; cnt++)
// 	{
// 		printf("0x%02x, ", test_cipher[cnt]);
// 		if((cnt & 0x07) == 0x07)
// 			printf("\n");
// 	}
// 	printf("\n");

// 	printf("\n加解密测试数据打印：\n");
// 	printf("\n原始明文：\n");
// 	for(cnt = 0; cnt < 32; cnt++)
// 	{
// 		printf("0x%02x, ", test_plain[cnt]);
// 		if((cnt & 0x07) == 0x07)
// 			printf("\n");
// 	}
// 	printf("\n");
 

// 	flag = AESCBCEnc(test_plain, 32, key, test_cipher);	
// 	if(flag == 0x55555555)
// 	{
// 		printf("处理数据长度错误！\n");
// 		return flag;
// 	}
// 	else if(flag == 0xffffffff)
// 	{
// 		printf("地址分配错误：\n");
// 		return flag;
// 	}


// 	printf("加密生成密文：\n");
// 	for(cnt = 0; cnt < 32; cnt++)
// 	{
// 		printf("0x%02x, ", test_cipher[cnt]);
// 		if((cnt & 0x07) == 0x07)
// 			printf("\n");
// 	}
// 	printf("\n");
	
// 	flag = AESCBCDec(test_cipher, 32, key, test_out);
// 	if(flag == 0x55555555)
// 	{
// 		printf("处理数据长度错误！\n");
// 		return flag;
// 	}
// 	else if(flag == 0xffffffff)
// 	{
// 		printf("地址分配错误：\n");
// 		return flag;
// 	}

	
// 	printf("密文解密产生明文：\n");
// 	for(cnt = 0; cnt < 32; cnt++)
// 	{
// 		printf("0x%02x, ", test_out[cnt]);
// 		if((cnt & 0x07) == 0x07)
// 			printf("\n");
// 	}
// 	printf("\n");


// 	return 0;
// }

}
